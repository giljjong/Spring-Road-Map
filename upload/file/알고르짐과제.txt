문제 1 :

1-1) O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(n^4)

1-2) 
O(1) = 1
O(logn) = 2.1072
O(n) = 128
O(nlogn)  = 269.7228
O(n^2) = 16384
O(n^3) = 2097152
O(n^4) = 268435456

문제 2 :
먼저 무게 1당 이익을 구한다.
(1, 3), (1, 4), (1, 7), (1,6), (1, 5)
이 중 가장 이익이 큰  3번을 먼저 채운다.
남은 가방 공간 : 21 - 4 = 16, 이익 : 28
두번째로 이익이 큰 4번을 채운다.
남은 가방공간 : 16 - 6 = 10, 이익 : 28 + 36 = 64
세번째로 이익이 큰 5번을 채운다.
남은 가방공간 : 10 - 3 = 7, 이익 : 64 + 15 = 79
네번째로 이익이 큰 2번을 채운다.
남은 가방공간 : 7 - 4 = 3, 이익 : 79 + 16 = 95
다섯번째로 이익이 큰 1번을 채우는데, 남은 공간만큼만 채운다.
남은 가방공간 : 3 - 3 = 0, 이익 : 95 + (27/3) = 104

최대 이익은 104이다.

문제 3 :

문제 4 :
(1) 먼저 가장 왼쪽 30을 피벗으로 잡고, 피벗 + 1 위치를 left, n(배열의 수) - 1 위치를 right로 잡는다.

(2) left는 오른쪽으로 이동하며 피벗보다 큰 수를 찾고, right 왼쪽으로 이동하며 피벗보다 작은 수를 찾는다.
left는 세번째 50, right는 여섯번째 25로 이 둘의 자리를 바꾼다.
결과 : A[] = {30, 10, 25, 45, 15, 50, 40}

(3) 다시 진행이 멈춘 지점으로부터 찾기를 진행한다.
left는 네번째 45, right는 다섯번째 15이다. 이 둘의 자리를 바꾼다.
결과 : A[] = {30, 10, 25, 15, 45, 50, 40}

(4) 다시 진행이 멈춘 지점으로 부터 찾기를 진행한다.
left는 다섯번째 45, right는 네번째 15이다. 이 둘의 크기를 비교하여 left > right일 경우 찾기를 멈추고 피벗을 배열의 중앙으로 이동시킨다. 중앙의 위치는 7(배열 크기) / 2 + 1 인 4의 위치로 이동시킨다.
결과 : A[] = {10, 25, 15, 30, 45, 50, 40}

(5) 피벗(30)을 중심으로 좌측과 우측을 다시 정렬한다.
좌측 10을 피벗으로 삼았을 때 나머지 수가 모두 피벗보다 크기때문에 자리에 변동을 하지 않는다.
다음 숫자인 25가 그 다음 숫자인 15보다 크기 때문에 둘의 자리를 교환한다.
결과 : A[] = {10, 15, 25, 30, 45, 50, 40}

(6) 우측 45를 피벗으로 삼고 left와 right를 구한다. left는 50 right는 40으로 left가 right보다 크기 때문에 둘의 자리를 바꾸어준다.
결과 : A[] = {10, 15, 25, 30, 45, 40, 50}

(7) 피벗 45의 위치를 중앙으로 이동시켜준다.
결과 : A[] = {10, 15, 25, 30, 40, 45, 50}

(8) 더이상 정렬할 것이 없기때문에 퀵 정렬을 종료한다.

4-2. 안정적인 정렬

퀵 정렬은 불안정적인 정렬이다. 왜냐하면 동일한 값이 있는 경우 처음의 순서를 보장하지 않기 때문이다. 예시로 